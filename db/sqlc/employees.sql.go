// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: employees.sql

package db

import (
	"context"
	"database/sql"
)

const createEmployee = `-- name: CreateEmployee :one
INSERT INTO employees (
 fullname, email, mobile, password, token
) VALUES (
 $1, $2, $3, $4, $5
)
RETURNING id, fullname, email, mobile, password, token, created_at, updated_at
`

type CreateEmployeeParams struct {
	Fullname string `json:"fullname"`
	Email    string `json:"email"`
	Mobile   string `json:"mobile"`
	Password string `json:"password"`
	Token    string `json:"token"`
}

func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, createEmployee,
		arg.Fullname,
		arg.Email,
		arg.Mobile,
		arg.Password,
		arg.Token,
	)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.Mobile,
		&i.Password,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEmployee = `-- name: DeleteEmployee :exec

DELETE FROM employees
WHERE id = $1
`

// -- name: ListEmployees :many
// SELECT * FROM employees
// ORDER BY id
// LIMIT $1
// OFFSET $2;
func (q *Queries) DeleteEmployee(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEmployee, id)
	return err
}

const getEmployeeByEmail = `-- name: GetEmployeeByEmail :one
SELECT id, fullname, email, mobile, password, token, created_at, updated_at FROM employees 
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetEmployeeByEmail(ctx context.Context, email string) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeByEmail, email)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.Mobile,
		&i.Password,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT id, fullname, email, mobile, password, token, created_at, updated_at FROM employees 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetEmployeeByID(ctx context.Context, id int64) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployeeByID, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.Mobile,
		&i.Password,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeeVisitors = `-- name: GetEmployeeVisitors :many
SELECT visitors.id, visitors.fullname, visitors.email, visitors.mobile, visitors.company_name, visitors.picture, visitors.sign_in, visitors.sign_out, visitors.employee_id
FROM employees
LEFT JOIN visitors ON employees.id=visitors.employee_id
WHERE employees.id = $1
AND sign_in >= NOW() - INTERVAL '24 HOURS'
`

type GetEmployeeVisitorsRow struct {
	ID          sql.NullInt64  `json:"id"`
	Fullname    sql.NullString `json:"fullname"`
	Email       sql.NullString `json:"email"`
	Mobile      sql.NullString `json:"mobile"`
	CompanyName sql.NullString `json:"company_name"`
	Picture     sql.NullString `json:"picture"`
	SignIn      sql.NullTime   `json:"sign_in"`
	SignOut     sql.NullTime   `json:"sign_out"`
	EmployeeID  sql.NullInt64  `json:"employee_id"`
}

func (q *Queries) GetEmployeeVisitors(ctx context.Context, id int64) ([]GetEmployeeVisitorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEmployeeVisitors, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEmployeeVisitorsRow{}
	for rows.Next() {
		var i GetEmployeeVisitorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Fullname,
			&i.Email,
			&i.Mobile,
			&i.CompanyName,
			&i.Picture,
			&i.SignIn,
			&i.SignOut,
			&i.EmployeeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployees = `-- name: ListEmployees :many
SELECT id, fullname, email, mobile, password, token, created_at, updated_at FROM employees 
ORDER BY id
`

func (q *Queries) ListEmployees(ctx context.Context) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Employee{}
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.ID,
			&i.Fullname,
			&i.Email,
			&i.Mobile,
			&i.Password,
			&i.Token,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loginEmployee = `-- name: LoginEmployee :one
UPDATE employees
SET token = $2,
updated_at = now()
WHERE email = $1
RETURNING id, fullname, email, mobile, password, token, created_at, updated_at
`

type LoginEmployeeParams struct {
	Email string `json:"email"`
	Token string `json:"token"`
}

func (q *Queries) LoginEmployee(ctx context.Context, arg LoginEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, loginEmployee, arg.Email, arg.Token)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.Fullname,
		&i.Email,
		&i.Mobile,
		&i.Password,
		&i.Token,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
