// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: visits.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createVisit = `-- name: CreateVisit :one
INSERT INTO visits (
 status,
 reason,
 employee_id,
 visitor_id
) VALUES (
 $1, $2, $3, $4
)
RETURNING id, status, reason, employee_id, visitor_id, created_at, updated_at
`

type CreateVisitParams struct {
	Status     string        `json:"status"`
	Reason     string        `json:"reason"`
	EmployeeID sql.NullInt64 `json:"employee_id"`
	VisitorID  int64         `json:"visitor_id"`
}

func (q *Queries) CreateVisit(ctx context.Context, arg CreateVisitParams) (Visit, error) {
	row := q.db.QueryRowContext(ctx, createVisit,
		arg.Status,
		arg.Reason,
		arg.EmployeeID,
		arg.VisitorID,
	)
	var i Visit
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Reason,
		&i.EmployeeID,
		&i.VisitorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVisit = `-- name: DeleteVisit :exec
DELETE FROM visits
WHERE id = $1
`

func (q *Queries) DeleteVisit(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteVisit, id)
	return err
}

const getVisitByVisitorID = `-- name: GetVisitByVisitorID :one
SELECT id, status, reason, employee_id, visitor_id, created_at, updated_at FROM visits 
WHERE visitor_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetVisitByVisitorID(ctx context.Context, visitorID int64) (Visit, error) {
	row := q.db.QueryRowContext(ctx, getVisitByVisitorID, visitorID)
	var i Visit
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Reason,
		&i.EmployeeID,
		&i.VisitorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVisitsByID = `-- name: GetVisitsByID :one
SELECT id, status, reason, employee_id, visitor_id, created_at, updated_at FROM visits 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetVisitsByID(ctx context.Context, id int64) (Visit, error) {
	row := q.db.QueryRowContext(ctx, getVisitsByID, id)
	var i Visit
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Reason,
		&i.EmployeeID,
		&i.VisitorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEmployeeVisits = `-- name: ListEmployeeVisits :many
SELECT visitors.fullname, visitors.email, visitors.mobile, visitors.company_name, visitors.picture, visitors.sign_in, visitors.sign_out, visits.status, visits.reason, visits.employee_id, visits.visitor_id, visits.created_at, visits.updated_at, visits.id
FROM visits
INNER JOIN visitors ON visits.visitor_id=visitors.id
WHERE visits.employee_id=$1
ORDER BY visits.created_at DESC
`

type ListEmployeeVisitsRow struct {
	Fullname    string        `json:"fullname"`
	Email       string        `json:"email"`
	Mobile      string        `json:"mobile"`
	CompanyName string        `json:"company_name"`
	Picture     string        `json:"picture"`
	SignIn      time.Time     `json:"sign_in"`
	SignOut     sql.NullTime  `json:"sign_out"`
	Status      string        `json:"status"`
	Reason      string        `json:"reason"`
	EmployeeID  sql.NullInt64 `json:"employee_id"`
	VisitorID   int64         `json:"visitor_id"`
	CreatedAt   time.Time     `json:"created_at"`
	UpdatedAt   sql.NullTime  `json:"updated_at"`
	ID          int64         `json:"id"`
}

func (q *Queries) ListEmployeeVisits(ctx context.Context, employeeID sql.NullInt64) ([]ListEmployeeVisitsRow, error) {
	rows, err := q.db.QueryContext(ctx, listEmployeeVisits, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeeVisitsRow{}
	for rows.Next() {
		var i ListEmployeeVisitsRow
		if err := rows.Scan(
			&i.Fullname,
			&i.Email,
			&i.Mobile,
			&i.CompanyName,
			&i.Picture,
			&i.SignIn,
			&i.SignOut,
			&i.Status,
			&i.Reason,
			&i.EmployeeID,
			&i.VisitorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisits = `-- name: ListVisits :many
SELECT v.id, v.status, v.reason, v.employee_id, v.visitor_id, v.created_at, v.updated_at, vi.fullname as visitor_name, vi.email as visitor_email, vi.mobile as visitor_mobile, vi.company_name, vi.picture as visitor_picture, vi.sign_in, vi.sign_out, e.fullname as employee_name, e.email as employee_email
FROM visits v
LEFT JOIN visitors vi ON vi.id = v.visitor_id
LEFT JOIN employees e ON e.id = v.employee_id
ORDER BY v.created_at DESC
`

type ListVisitsRow struct {
	ID             int64          `json:"id"`
	Status         string         `json:"status"`
	Reason         string         `json:"reason"`
	EmployeeID     sql.NullInt64  `json:"employee_id"`
	VisitorID      int64          `json:"visitor_id"`
	CreatedAt      time.Time      `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	VisitorName    sql.NullString `json:"visitor_name"`
	VisitorEmail   sql.NullString `json:"visitor_email"`
	VisitorMobile  sql.NullString `json:"visitor_mobile"`
	CompanyName    sql.NullString `json:"company_name"`
	VisitorPicture sql.NullString `json:"visitor_picture"`
	SignIn         sql.NullTime   `json:"sign_in"`
	SignOut        sql.NullTime   `json:"sign_out"`
	EmployeeName   sql.NullString `json:"employee_name"`
	EmployeeEmail  sql.NullString `json:"employee_email"`
}

func (q *Queries) ListVisits(ctx context.Context) ([]ListVisitsRow, error) {
	rows, err := q.db.QueryContext(ctx, listVisits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListVisitsRow{}
	for rows.Next() {
		var i ListVisitsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Reason,
			&i.EmployeeID,
			&i.VisitorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.VisitorName,
			&i.VisitorEmail,
			&i.VisitorMobile,
			&i.CompanyName,
			&i.VisitorPicture,
			&i.SignIn,
			&i.SignOut,
			&i.EmployeeName,
			&i.EmployeeEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVisitsByStatus = `-- name: ListVisitsByStatus :many
SELECT id, status, reason, employee_id, visitor_id, created_at, updated_at FROM visits 
WHERE status = $1
ORDER BY id
`

func (q *Queries) ListVisitsByStatus(ctx context.Context, status string) ([]Visit, error) {
	rows, err := q.db.QueryContext(ctx, listVisitsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Visit{}
	for rows.Next() {
		var i Visit
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Reason,
			&i.EmployeeID,
			&i.VisitorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVisit = `-- name: UpdateVisit :one
UPDATE visits
SET
status = $4,
reason = $5,
updated_at = now()
WHERE id = $1
AND visitor_id = $2
AND employee_id = $3
RETURNING id, status, reason, employee_id, visitor_id, created_at, updated_at
`

type UpdateVisitParams struct {
	ID         int64         `json:"id"`
	VisitorID  int64         `json:"visitor_id"`
	EmployeeID sql.NullInt64 `json:"employee_id"`
	Status     string        `json:"status"`
	Reason     string        `json:"reason"`
}

func (q *Queries) UpdateVisit(ctx context.Context, arg UpdateVisitParams) (Visit, error) {
	row := q.db.QueryRowContext(ctx, updateVisit,
		arg.ID,
		arg.VisitorID,
		arg.EmployeeID,
		arg.Status,
		arg.Reason,
	)
	var i Visit
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Reason,
		&i.EmployeeID,
		&i.VisitorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
